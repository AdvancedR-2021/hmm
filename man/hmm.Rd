% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmm.R
\name{hmm}
\alias{hmm}
\title{Fitting Hidden Markov Models}
\usage{
hmm(x, Gamma, delta, dist = "custom", ..., estimate = !is.null(x))
}
\arguments{
\item{x}{Numeric vector of observed emissions. Can be \code{NULL} if no estimation is desired.}

\item{Gamma}{Initial value of transition probability matrix for underlying Markov chain.}

\item{delta}{Numeric vector of probabilities of the initial distribution of the Markov chain.}

\item{dist}{Distribution family of emissions. Can be one of 'poisson', 'normal', 'binom', 'exponential' or 'custom'. If 'custom', user must provide own functions for densities, MLEs and random generation (see details)}

\item{...}{Parameters of emission distribution as well as parameters for EM-algorithm. See details.}

\item{estimate}{Logical variable whether or not parameters of model (Gamma, delta and emission parameters) should be estimated by EM-algorithm. Defaults to \code{TRUE} when data is available.}
}
\value{
An object of class 'hmm'.
The 'hmm'-class is equipped with a variety of default methods, see 'See also' section for details.
An object of class 'hmm' is a list containing at least the following components:\tabular{ll}{
    \tab  \cr
   \code{m} \tab Number of hidden states. \cr
   \code{dist} \tab Distribution family of emissions. \cr
   \code{Gamma} \tab The transition probability matrix of the underlying Markov chain. \cr
   \code{delta} \tab The initial distribution of the underlying Markov chain. \cr
   \code{parameters} \tab List of parameters for the emission distribution family. \cr
   \code{rdists} \tab List of functions used for simulating. Only for internal use. \cr
}


If \code{x} is not \code{NULL}, it will also include:\tabular{ll}{
    \tab  \cr
   \code{x} \tab Vector of observations. \cr
   \code{n} \tab Number of observations. \cr
   \code{logLik} \tab Log-likelihood of parameters given the observed data. \cr
   \code{AIC} \tab AIC of the model. \cr
   \code{BIC} \tab BIC of the model. \cr
   \code{viterbi_s} \tab States of global decoding of the model. \cr
   \code{posterior_s} \tab States of local decoding of the model. \cr
   \code{viterbi_s} \tab Probs. of global decoding of the model. \cr
   \code{posterior_s} \tab Probs. of local decoding of the model. \cr
}


Finally, if estimation is performed, it will also include the following:\tabular{ll}{
    \tab  \cr
   \code{EMlogLik} \tab Vector of log-likelihoods at each iteration in the EM-algorithm. \cr
   \code{n_iter} \tab Number of iterations performed in the EM-algorithm. \cr
}
}
\description{
\code{hmm} is used to fit (or simply define) Hidden Markov Models.
Most commonly, it will be used to simply fit a vector of observed emissions which come from a (known) common distribution family to a hidden Markov model, where the parameters of the underlying Markov chain as well as the emission distribution family is then fitted using the EM-algorithm.

Alternatively, one can use custom distribution families by providing various functions (see details).

Finally, one can also disable optimization altogether to simply obtain an 'hmm'-object which can then be assessed through various standard methods (see below).
}
\details{
\subsection{Theory}{

This function is used to fit or define a hidden Markov model, i.e. a model where the distributions of X_1, ..., X_n (the
emissions) depend on a hidden sequence Y_1, ..., Y_n (the hidden states).
In particular, in this model, Y_1, ..., Y_n constitutes a Markov chain on the finite state space {1, ..., m}, and the
distribution of X_i depends only on the value of Y_i, i.e. X_i | Y_i=k ~ X_j | Y_j=k for all i, j.

As such, to estimate parameters in this model, one must estimate not only the parameters of the m emission distributions,
but also the parameters of the Markov chain, i.e. the initial distribution delta (that is, Y_1 ~ delta) and the transition
matrix Gamma (that is, P(Y_k=j | Y_(k-1)=i)=Gamma_i,j)
}

\subsection{Argument details}{

The \code{dist} and \code{...} arguments determine the distribution of the emissions in the different states.
If \code{dist} is one of 'poisson', 'normal', 'binom' or 'exponential', distribution parameters must be passed to the \code{...} argument.
In particular they must have the following format:\tabular{lll}{
    \tab  \tab  \cr
   'poisson' \tab \code{lambda} \tab A vector of Poisson parameters, one per hidden state. \cr
   'normal' \tab \code{mean}, \code{sd} \tab Vectors of means and standard deviations, one per hidden state. \cr
   'binom' \tab \code{size}, \code{prob} \tab \code{size} is a single integer, denoting the common size for all hidden states, while \code{prob} is a vector of success probabilities, one per hidden state. \cr
   'exponential' \tab \code{rate} \tab Vector of rates for the exponential distributions, one per hidden state. \cr
}


If \code{dist} is 'custom', user must provide the following:\tabular{ll}{
    \tab  \cr
   \code{lls} \tab Function or list of functions, where each function is on the form \code{f(x, param)}, and returns the conditional density of X_i given the parameter \code{param}. \cr
   \code{params_lls} \tab List of parameters, one for each state. Must fit with \code{lls} in the sense that \code{lls(x, param[[i]])} (or \code{lls[[i]](x, param[[i]])} if \code{lls} is a list) denotes the density in point x of X_j given Y_j=i \cr
   \code{lls_mle} \tab Function or list of functions, which return the maximum likelihood estimates given the provided data \code{x} and a vector (of equal length) of scalars \code{u} where each scalar is between 0 and 1. That is, the function(s) must be on the form \code{h(x, u)} and must return the value of \code{param} maximizing \code{sum(u * log(f(x, param)))}. \cr
   \code{rdist} \tab Function or list of functions that generate random emissions from the different hidden states. The function(s) must be on the form \code{r(n, param)} and must return a vector of \code{n} random realizations given the parameter \code{param}. \cr
}


For each of \code{lls}, \code{lls_mle} and \code{rdist}, if the distribution family itself (and not just the parameters) depends on the hidden state, a list of functions must be provided, one for each state.

Finally, \code{...} also takes arguments passed to the EM-algorithm, namely: \code{epsilon}, .\tabular{ll}{
    \tab  \cr
   \code{epsilon} \tab The value at which estimation halts, if the difference in log-likelihood between iterations falls below \cr
   \code{max_iter} \tab Maximum number of iterations before halting. \cr
}

}
}
\examples{
# Annual counts of earthquakes magnitude 7 or greater, 1900-2006.
# Source:
# Earthquake Data Base System of the U.S. Geological Survey, National
# Earthquake Information Center, Golden CO

quakes <- read.table("http://www.hmms-for-time-series.de/second/data/earthquakes.txt")$V2
Gamma <- rbind(c(0.9, 0.1), c(0.1, 0.9))
delta <- c(1, 1)/2
lambda <- c(10, 30)
hmm.EQ <- hmm(quakes, Gamma, delta, dist='poisson', lambda=lambda)
hmm.EQ

# If one does not want estimation by EM algorithm (e.g. for comparison of summary statistics), it can be disabled
hmm.EQ_no_opt <- hmm(quakes, Gamma, delta, dist='poisson', lambda=lambda, estimate=FALSE)
hmm.EQ_no_opt

# Creating 'empty' hmm object for sake of simulation (see simulate for further details)
# Here where all emission distributions are normal
Gamma <- rbind(c(0.5, 0.25, 0.25),
               c(0.1, 0.8 , 0.1),
               c(  0, 0.2 , 0.8))
delta <- c(1, 0, 0)
mean <- c(0, 5, 10)
sd <- rep(1, 3)

hmm.normal <- hmm(NULL, Gamma=Gamma, delta=delta, dist='normal', mean=mean, sd=sd)
hmm.normal

# Here, the emission distributions are custom (Uniform[0, theta])
Gamma <- rbind(c(0.5, 0.25, 0.25),
               c(0.1, 0.8 , 0.1),
               c(  0, 0.2 , 0.8))
delta <- c(1, 0, 0)
theta <- list(1, 5, 10)
lls <- function(x, param){dunif(x, 0, param)}
lls_mle <- function(x, u){max(x)}
rdist <- function(n, param){runif(n, 0, param)}
hmm.unif <- hmm(NULL, Gamma=Gamma, delta=delta, lls=lls, param_lls=theta, lls_mle=lls_mle, rdist=rdist)
hmm.unif

# Here, the emission distributions is either normal(0, 1) or exponential(1)
Gamma <- rbind(c(0.2, 0.8),
               c(0.8, 0.2))
delta <- c(1, 1)/2
param <- list(c(0, 1), 1)

lls <- list(function(x, param){dnorm(x, param[1], param[2])},
            function(x, param){dexp(x, param)})

lls_mle <- list(function(x, u){mean_hat <- sum(u*x) / sum(u); c(mean_hat, sqrt(sum(u*(x-mean_hat)^2) / sum(u)))},
                function(x, u){sum(u)/sum(u*x)})

rdist <- list(function(n, param){do.call(rnorm, args=as.list(c(n, param)))},
              function(n, param){rexp(n, param)})

hmm.mixture <- hmm(NULL, Gamma=Gamma, delta=delta, lls=lls, param_lls=param, lls_mle=lls_mle, rdist=rdist)
hmm.mixture
}
\seealso{
The \code{hmm} object has methods for the following generic functions:
\link[=AIC.hmm]{AIC}, \link[=BIC.hmm]{BIC}, \link[=fitted.hmm]{fitted.values}, \link[=logLik.hmm]{logLik}, \link[=plot.hmm]{plot}, \link[=print.hmm]{print}, \link[=residuals.hmm]{residuals}, \link[=simulate.hmm]{simulate} and \link[=summary.hmm]{summary}.
Some (most) of these are only available, when data is provided, i.e. when \code{x} is not \code{NULL}.
}
